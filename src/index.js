export {
    isCompilerError,
    makeErrorCollector,
    makeReferenceError,
    makeSyntaxError,
    makeTypeError
} from "./errors/index.js"
export { translateImportPaths } from "./formatters/index.js"
export { readHeader } from "./readers/index.js"
export {
    anySymbol,
    anyWord,
    boollit,
    byteslit,
    group,
    intlit,
    isDummySite,
    makeBoolLiteral,
    makeByteArrayLiteral,
    makeComment,
    makeDummySite,
    makeGroup,
    makeIntLiteral,
    makeRealLiteral,
    makeSource,
    makeStringLiteral,
    makeSymbolToken,
    makeTokenizer,
    makeTokenReader,
    makeTokenSite,
    makeWord,
    oneOf,
    reallit,
    strlit,
    symbol,
    wildcard,
    word,
    REAL_PRECISION
} from "./tokens/index.js"

/**
 * @import { AssertExtends, AssertTrue, IsSame, UnwrapSingleton } from "@helios-lang/type-utils"
 */

/**
 * @typedef {object} Pos
 * Position in a source file represented by a line number and a column number.
 *
 * @prop {number} line
 * @prop {number} column
 */

/**
 * @typedef {AssertExtends<Pos, Site>}
 * @typedef {object} Site
 * Source map site containing all necessary information to link a symbol in the output generated by the compiler process back to the original piece of source code.
 *
 * @prop {string} file
 * @prop {number} line
 * @prop {number} column
 * @prop {Pos | undefined} end
 * Optional range end of the Site
 *
 * @prop {string | undefined} description
 * The description is used to attach context information to UPLC symbols to provide more detailed stack traces
 *
 * @prop {() => string} toString
 * Outputs "<file>:<line>:<column>"
 *
 * @prop {(description: string) => Site} withDescription
 * Creates a copy of the Site containing the given description
 */

/**
 * @typedef {"ReferenceError" | "SyntaxError" | "TypeError"} CompilerErrorKind
 */

/**
 * @typedef {AssertExtends<Error, CompilerError>}
 * @typedef {object} CompilerError
 * An error thrown by the compiler process. Can be a reference, syntax or type error.
 *
 * @prop {"CompilerError"} name
 * @prop {CompilerErrorKind} kind
 * @prop {Site} site
 * Source code location of error
 *
 * @prop {string} message
 * Displayed message
 *
 * @prop {string} originalMessage
 * Unformatted message
 *
 * @prop {CompilerError[] | undefined} otherErrors
 * When an {@link ErrorCollector} has more than 1 error and {@link ErrorCollector.throw} is called, the first error is thrown and the remaining are attached to it.
 */

/**
 * @typedef {object} ErrorCollector
 * An `ErrorCollector` accumulates `CompilerError`s so that at the end of the
 * compilation process all errors are logged at once, and all errors can be
 * displayed in the IDE.
 *
 * Use {@link makeErrorCollector} to create a new `ErrorCollector`.
 *
 * @prop {CompilerError[]} errors
 * The list of compiler errors collected
 *
 * @prop {(site: Site, msg: string) => void} syntax
 * Adds a syntax error
 *
 * @prop {() => void} throw
 * Throws an error if it contains some errors
 */

/**
 * The key is the char index in the new source (which is being mapped to the old source using the Site value)
 * @typedef {Map<number, Site>} SourceMap
 */

/**
 * length is a separate field because of performance
 * @typedef {object} Source
 * @prop {string} content
 * @prop {string} name
 * @prop {number} length
 * @prop {number[]} lineEndLocations
 * @prop {(i: number) => string} getChar
 * @prop {(i: number) => string} getWord
 * @prop {(i: number) => [number, number]} getPosition
 * @prop {() => string} pretty
 */

/**
 * @typedef {object} BoolLiteral
 * @prop {Site} site
 * @prop {"bool"} kind
 * @prop {boolean} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {object} ByteArrayLiteral
 * Use {@link makeByteArrayLiteral} to create a `ByteArrayLiteral`
 *
 * @prop {Site} site
 * @prop {"bytes"} kind
 * @prop {number[]} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {object} Comment
 * @prop {Site} site
 * @prop {"comment"} kind
 * @prop {string} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {"(" | "{" | "["} GroupKind
 */

/**
 * @typedef {")" | "}" | "]"} GroupCloseKind
 */

/**
 * @template {Token[] | TokenReader} F
 * @typedef {object} GenericGroup
 * @prop {Site} site
 * @prop {GroupKind} kind
 * @prop {F[]} fields
 * @prop {SymbolToken[]} separators
 * @prop {string| undefined} error
 * @prop {(kind?: string | undefined, nFields?: number) => boolean} isGroup
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * Can't alias GenericGroup<Token[]> because that gives a circular reference error
 * @typedef {AssertTrue<IsSame<TokenGroup, GenericGroup<Token[]>>>}
 * @typedef {object} TokenGroup
 * @prop {Site} site
 * @prop {GroupKind} kind
 * @prop {Token[][]} fields
 * @prop {SymbolToken[]} separators
 * @prop {string| undefined} error
 * @prop {(kind?: string | undefined, nFields?: number) => boolean} isGroup
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 *
 * @typedef {object} IntLiteral
 * @prop {Site} site
 * @prop {"int"} kind
 * @prop {bigint} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {object} RealLiteral
 * @prop {Site} site
 * @prop {"real"} kind
 * @prop {bigint} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {object} StringLiteral
 * @prop {Site} site
 * @prop {"string"} kind
 * @prop {string} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @template {string} [T=string]
 * @typedef {object} SymbolToken
 * @prop {Site} site
 * @prop {"symbol"} kind
 * @prop {T} value
 * @prop {(other: Token) => other is SymbolToken<T>} isEqual
 * @prop {(value: string | ReadonlyArray<string>) => boolean} matches
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {object} Word
 * @prop {Site} site
 * @prop {"word"} kind
 * @prop {string} value
 * @prop {(other: Token) => boolean} isEqual
 * @prop {() => boolean} isInternal
 * @prop {() => boolean} isKeyword
 * @prop {(value: string | ReadonlyArray<string>) => boolean} matches
 * @prop {(preserveWhitespace?: boolean) => string} toString
 */

/**
 * @typedef {(
 *   BoolLiteral
 *   | ByteArrayLiteral
 *   | Comment
 *   | IntLiteral
 *   | RealLiteral
 *   | StringLiteral
 *   | SymbolToken
 *   | TokenGroup
 *   | Word
 * )} Token
 */

/**
 * @typedef {object} Tokenizer
 * @prop {ErrorCollector} errors
 * @prop {(nestGroups?: boolean) => Token[]} tokenize
 * @prop {() => Generator<Token>} stream
 */

/**
 * The generic type parameter must be used somewhere inside this definition, otherwise typescript fails to infer T inside the TokenReader.matches method
 * The easiest way to do this is return a truthy value from matches() instead of just a boolean
 * @template {Token} [T=Token]
 * @typedef {object} TokenMatcher
 * Token matchers are combined with {@link TokenReader} in order to match sequences of tokens.
 * The following token matchers are available:
 *   - {@link anySymbol}
 *   - {@link anyWord}
 *   - {@link reallit}
 *   - {@link wildcard} (any Token)
 *   - {@link boollit}
 *   - {@link byteslit}
 *   - {@link group}
 *   - {@link intlit}
 *   - {@link oneOf}
 *   - {@link strlit}
 *   - {@link symbol}
 *   - {@link word}
 * @prop {(t: Token) => T | undefined} matches
 * @prop {() => string} toString
 */

/**
 * @template {TokenMatcher[]} Matchers
 * @typedef {{[M in keyof Matchers]: Matchers[M] extends TokenMatcher<infer T> ? (T extends GenericGroup<Token[]> ? GenericGroup<TokenReader> : T) : never}} MapMatchersToTokens
 * Maps a tuple of matchers to a tuple of equivalent token types:
 *   - TokenMatcher<{@link BoolLiteral}> is mapped to {@link BoolLiteral}
 *   - TokenMatcher<{@link ByteArrayLiteral}> is mapped to {@link ByteArrayLiteral}
 *   - TokenMatcher<{@link Comment} is mapped to {@link Comment}
 *   - TokenMatcher<{@link IntLiteral} is mapped to {@link IntLiteral}
 *   - TokenMatcher<{@link RealLiteral} is mapped to {@link RealLiteral}
 *   - TokenMatcher<{@link StringLiteral} is mapped to {@link StringLiteral}
 *   - TokenMatcher<{@link SymbolToken} is mapped to {@link SymbolToken}
 *   - TokenMatcher<{@link TokenGroup}> is augmented and mapped {@link GenericGroup}<{@link TokenReader}>
 *   - TokenMatcher<{@link Word}> is mapped to {@link Word}
 */

/**
 * @typedef {object} TokenReader
 * @prop {Token[]} tokens
 * @prop {ErrorCollector} errors
 * @prop {Token[]} rest
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => TokenReader} assert
 * @prop {() => void} end
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => [TokenReader, ...MapMatchersToTokens<Matchers>] | undefined} findNext
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => [TokenReader, ...MapMatchersToTokens<Matchers>] | undefined} findNextMatch
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => [TokenReader, ...MapMatchersToTokens<Matchers>] | undefined} findLast
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => [TokenReader, ...MapMatchersToTokens<Matchers>] | undefined} findLastMatch
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => TokenReader} readUntil
 * @prop {() => boolean} isEof
 * @prop {<Matchers extends TokenMatcher[]>(...matchers: [...Matchers]) => UnwrapSingleton<MapMatchersToTokens<Matchers>> | undefined} matches
 * @prop {(throwFail?: boolean | string) => TokenReader} endMatch
 * @prop {() => void} unreadToken
 */
